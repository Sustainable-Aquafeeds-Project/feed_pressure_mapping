---
title: "Spatial Allocation of Crop Demand"
output: html_document
---

```{r}
library(tidyverse)
library(here)
library(terra)
library(parallel)

source(here("src/directories.R"))
source(here("src/spatial.R"))

base_raster_ea <- rast(here("data/spatial/base_raster_gall_peters.tif"))

select <- dplyr::select
```

This chunk of code brings in the crop production raster (only the production layers for all types) and reprojects to equal area projections for each crop)
```{r}

crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

crop_list <- unique(crop_demand$map_spam_code)

crop_production_files <- list.files(file.path(mapspam_dir, "new-extents"), full.names = TRUE)[grep(pattern = "_P_", list.files(file.path(mapspam_dir, "new-extents"), full.names = TRUE))] 

these_crop_production_files <- crop_production_files[grepl("MAIZ_A|OPUL_A|WHEA_A|RAPE_A|OOIL_A|SOYB_A|SUNF_A", crop_production_files)]


#for testing the below function
this_code <- crop_list[[1]]
this_filepath <- these_crop_production_files[[5]]


#NOTE::: the function below runs fine (i.e. raster files are reprojected and produced) but introducing terra spat rasters instead of raster::rasters created an error "Error in x@ptr$nrow() : external pointer is not valid" when printing the raster. Still searching for solutions. It is to do with parallelisng SpatRaster see - https://github.com/rspatial/terra/issues/166 . So have switched to lapply to make sure code runs.

lapply(X = these_crop_production_files, FUN = \(this_filepath){
  
  this_file <- basename(this_filepath)
      
    #import the raster
    imported_file <- rast(this_filepath)
    
    #reproject the file
    reprojected_file <-  project(x=imported_file, y= base_raster_ea)
    
    #write the original and the reprojected to this project
    writeRaster(imported_file, filename = paste0(here("data/spatial/01-crop-layers-raw/"), this_file), overwrite = TRUE)
    writeRaster(reprojected_file, filename = paste0(here("data/spatial/02-crop-layers-reprojected/"), this_file), overwrite=TRUE)
  
  
})
  

#this code is need for the physical area layers stuff in the biodiversity paper so leaving in for now. 
    #imported_file <- imported_file*0.01 #converts the imported raster to km2 from ha 
    

```

We're now interested from where the different crop ingredients could be sourced across the top producing nations. Need to check whether the demand from the global salmon industry

```{r}
crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

#check that demand for each rawe material on each country in the various diets does not outsrtip national production (if so we need to adjust AllocateSpatialCropDemand function to be more defensive).

top_10_producers <- read_csv(here("data/tidy_data/production-data/top_crop_producers_conversions.csv")) |> 
  mutate(ingredient = if_else(ingredient == "canola/camelina oil", true = "canola_camelina oil", false = ingredient))


(crop_demand_production_compare <- 
  crop_demand |> 
  left_join(top_10_producers |> 
              select(-c(cf, X7)), 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
    mutate(demand_production_ratio = total_crop_demand/mean_value,
           check = demand_production_ratio>1) %>% 
    rename(national_production = mean_value)
    
    )

#Demand only exceeds production for the top 3 producers for guar (only India can support this demand from global salmon. But this isn't bad given we only have footprint information for India)

crop_demand_production_compare |> 
  group_by(ingredients, diet) |> 
  mutate(producer_order = 1:10) |> 
  filter(check != TRUE)


#saveRDS(object = crop_demand_production_compare, file = here("data/tidy_data/demand/crop_demand_production_compare.rds"))


```

Make some decisions about which countries to include. The idea is to deliberately select countries that have variable environmental midpoints to illustrate the relative contribution of source and diet. Import the agrifootprint data and filter by the countries that can support

```{r}
#import the crop lca data
all_crop_pressures <-  readRDS(file = here("data/tidy_data/LCA/crop_lca.rds"))

sort(unique(all_crop_pressures$impact_category))

#filter for the pressures of interest
crop_main_pressures <- all_crop_pressures |> filter(impact_category %in% c("Global warming", "Climate change", "Climate change - Land use and LU change", "Climate change - Fossil", "Climate change - Biogenic", "Water use",  "Water consumption", "Eutrophication, freshwater", "Eutrophication, marine", "Land use", "Freshwater eutrophication", "Marine eutrophication"))

#check that five facets are available across all materials (i.e. GWP, FW eutrophication, marine eutrophication, land use, water use). There is with the exception of soybeans that has an extra 3 GWP categories
crop_main_pressures |> 
  select(raw_material, impact_category) |> 
  distinct() |> 
  group_by(raw_material) |> 
  count()



#match up country-specific pressure data with country production/demand data. Want to constrain the ocujntries used for LCA variability by those that can plausibly source demand

(plausible_crop_sourcing_list <- crop_demand_production_compare |> select(ingredients, diet, FAOSTAT_name, source_iso3c, total_crop_demand, national_production, demand_production_ratio, check) |>  filter(check == FALSE) |> group_split(ingredients))

which_crop_countries <- \(this_df){
  
  this_raw_material <- this_df$FAOSTAT_name |> unique()
  these_countries <- this_df$source_iso3c |> unique()
  this_return_df <- bind_cols(FAOSTAT_name = this_raw_material, iso3c = these_countries, plausible = TRUE)
  
}

(plausible_crop_sourcing <- map_df(.x = plausible_crop_sourcing_list, .f = which_crop_countries) |> distinct() |> add_row(FAOSTAT_name = "Pulses nes", iso3c = "IND", plausible = TRUE))

#filter impact information for those it is plausible to source from. USA is conspicuously missing from soybeans - need to follow up.
plausible_crops_w_impact <- crop_main_pressures |> filter(raw_material != "Lupins") |> 
  left_join(plausible_crop_sourcing,  by = c("iso3c", "FAOSTAT_name")) |> 
  drop_na(plausible) 

#are at least 3 countries available where they can plausibly sourcing demand and with which we have impacts?
#No - guar and linseed have 1 and 2 respectively so can adjust so that
plausible_crops_w_impact |> 
  group_by(raw_material, impact_category) |> 
  count()

#for each raw material and country  - add impact category values as an indicator of total footprint variability among countries to get at the large differences, then get the min, median and max

#first get guar cumulative score to add later down (the one value causing problems in if_else statement)
guar_seed_cum_value <- plausible_crops_w_impact |> 
  filter(raw_material == "Guar seed") |> 
  group_by(raw_material, FAOSTAT_name, iso3c) |> 
  summarise(cum_value = sum(value)) |> pull(cum_value)

#these countries for each crop create the greatest range of midpoint impacts across sources
crop_sourcing_countries <- 
  plausible_crops_w_impact |> 
  filter(raw_material != "Guar seed") |> 
  group_by(raw_material, FAOSTAT_name, iso3c) |> 
  summarise(cum_value = sum(value)) |> 
  summarise(min = min(cum_value),
            mid = if_else(condition = length(cum_value)%%2==0 & length(cum_value)>1, 
                          true = sort(cum_value)[length(cum_value)/2], 
                          false = median(cum_value)),
            max = max(cum_value)) |> 
  ungroup() |> 
  add_row(raw_material = "Guar seed", FAOSTAT_name = "Pulses nes", min = guar_seed_cum_value, mid = guar_seed_cum_value, max = guar_seed_cum_value) |> 
  pivot_longer(names_to = "value_range", values_to = "cum_value", -c(raw_material, FAOSTAT_name)) |> 
  left_join(plausible_crops_w_impact |> 
              group_by(raw_material, FAOSTAT_name, iso3c) |> 
              summarise(cum_value = sum(value)), by = c("raw_material", "FAOSTAT_name", "cum_value"))

saveRDS(object = crop_sourcing_countries, file = here("data/tidy_data/demand/crop_sourcing_countries_plausible_impacts.rds"))
  


```


Now we can use the countries which can plausibly support salmon feed demands and for which we have midpoint impacts for to spatially allocate crop demand to these producing countries - rather than just using the top 3 producers for example.

```{r}

#import sourcing countries data and crop demand data if only running this chunk
crop_sourcing_countries <- readRDS(file = here("data/tidy_data/demand/crop_sourcing_countries_plausible_impacts.rds"))
crop_demand_production_compare <- readRDS(here("data/tidy_data/demand/crop_demand_production_compare.rds"))

ingredient_per_country_per_diet_all <- 
  crop_demand_production_compare |>  filter(total_ingredient_demand != 0) |> group_split(diet, ingredients, FAOSTAT_name)



#filter each combo of diet, ingredient and raw-material by the source countries decided above
ingredient_per_country_per_diet <- 
  
  map_df(ingredient_per_country_per_diet_all, \(this_raw_material_source){
  
  this_raw_material <- this_raw_material_source$FAOSTAT_name |> unique()
  
  these_sources <- crop_sourcing_countries |> filter(FAOSTAT_name == this_raw_material) |> pull(iso3c) 
  
  filter_df <-  this_raw_material_source|> filter(source_iso3c %in% these_sources)
  
}) |> 
  group_split(diet, ingredients, FAOSTAT_name, source_iso3c)



#allocating demand on spatial production layers by diet, ingredient, and source country
AllocateSpatialCropDemand <- \(this_ingredient_source){
  
  #parameters within diet-ingredient-source demand data
  this_diet <- unique(this_ingredient_source$diet)
  
  this_country <- unique(this_ingredient_source$source_iso3c)
  
  this_ingredient <- unique(this_ingredient_source$ingredients)
  
  this_mapspam_code <- unique(this_ingredient_source$map_spam_code)
  
  this_demand_quantity <- unique(this_ingredient_source$total_crop_demand)
  
  this_country_production <- unique(this_ingredient_source$national_production)
  
  #the file_name of interest for this diet, ingredient, and country
  this_demand_raster_filename <- here(sprintf("data/spatial/%s/%s_AllTech_%s.tif", this_diet, this_ingredient, this_country))
  
  #if the file name doesn't exist, create it
  if(file.exists(this_demand_raster_filename)){
    
    #spatial adjustments of production data by current production
    this_country_raster <- rast(here(sprintf("data/spatial/00-country-rasters/%s.tif", this_country)))
    
    this_global_production_raster <- rast(list.files(here("data/spatial/02-crop-layers-reprojected"), pattern = sprintf("_P_%s_A", toupper(this_mapspam_code)), full.names = TRUE))
    
    this_country_production_raster <- this_global_production_raster*this_country_raster
    
    this_updated_country_production_raster <-  this_country_production_raster* this_current_production/sum(terra::values(this_country_production_raster), na.rm=TRUE)
    
    this_demand_production_ratio <-
      min(1, this_demand_quantity/this_current_production)
  
    this_demand_raster <- this_updated_country_production_raster*this_demand_production_ratio
      
    terra::writeRaster( x=this_demand_raster, filename =  this_demand_raster_filename, overwrite=TRUE)
    
  }
}

mclapply(X = ingredient_per_country_per_diet, FUN = AllocateSpatialCropDemand, mc.cores = detectCores()-2)



this_ingredient_source <- ingredient_per_country_per_diet[[1]]

bind_rows(ingredient_per_country_per_diet)

```

