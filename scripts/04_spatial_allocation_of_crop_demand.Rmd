---
title: "Spatial Allocation of Crop Demand"
output: html_document
---

```{r}
library(tidyverse)
library(here)
library(terra)
library(parallel)

source(here("src/directories.R"))
source(here("src/spatial.R"))

base_raster_ea <- rast(here("data/spatial/base_raster_gall_peters.tif"))

select <- dplyr::select
```

This chunk of code brings in the crop production raster (only the production layers for all types) and reprojects to equal area projections for each crop)
```{r}

crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

crop_list <- unique(crop_demand$map_spam_code)

#for testing the below function
# this_code <- crop_list[[1]]
# this_filepath <- these_crop_files[[1]]


#this runs fine (i.e. raster files are reprojected and produced) but introducing terra spat rasters instead of raster::rasters created an error "Error in x@ptr$nrow() : external pointer is not valid" when printing the raster

map(.x=crop_list, .f = \(this_code){
  
  message("Processing crop code ", this_code)
  
  #identify files for each crop across irrigated, rainfed high inputs, rainfed low input - assuming that subsistence does not enter global feed supply chains 
  these_crop_files <- list.files(file.path(mapspam_dir, "new-extents"), pattern = sprintf("_P_%s_I|_P_%s_H|_P_%s_L|_P_%s_S", toupper(this_code), toupper(this_code), toupper(this_code), toupper(this_code)), full.names = TRUE)
    
  mclapply(X = these_crop_files, FUN = \(this_filepath){
  
    this_file <- basename(this_filepath)
    
    #import the raster
    imported_file <- rast(this_filepath)
    
    #this code is need for the physical area layers stuff in the biodiversity paper so leaving in for now. 
    #imported_file <- imported_file*0.01 #converts the imported raster to km2 from ha 
    
    reprojected_file <-  project(x=imported_file, y= base_raster_ea)
    #reprojected_file <- (reprojected_file) 
    
    writeRaster(imported_file, filename = paste0(here("data/spatial/01-crop-layers-raw/"), this_file), overwrite=TRUE)
    writeRaster(reprojected_file, filename = paste0(here("data/spatial/02-crop-layers-reprojected/"), this_file), overwrite=TRUE)
  }, 
  mc.cores = detectCores()-2)
})


```


We're interested in the impacts of different diets depending on their make-up and where they are sourced from so probably organise the spatial outputs by diet but also the source country and the ingredient (rather than the crop as we want impacts to be associated per ingredient).


```{r}

crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

#check that demand for each rawe material on each country in the various diets does not outsrtip national production (if so we need to adjust AllocateSpatialCropDemand function to be more defensive).

top_10_producers <- read_csv(here("data/tidy_data/production-data/top_crop_producers_conversions.csv")) |> 
  mutate(ingredient = if_else(ingredient == "canola/camelina oil", true = "canola_camelina oil", false = ingredient))



(demand_production_compare <- 
  crop_demand |> 
  left_join(top_10_producers |> 
              select(-c(cf, X7)), 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
    mutate(demand_production_ratio = total_crop_demand/mean_value,
           check = demand_production_ratio>1)
    
    )




#demand exceeds average production between
(countries_crops_demand_greaterthan_production <- demand_production_compare |> filter(check==TRUE) |> arrange(-demand_production_ratio))

ingredient_per_country_per_diet <- 
  crop_demand |> 
  left_join(top_10_producers |> 
              select(-c(cf, X7, iso3c)), 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
  group_split(diet, ingredients, source_country)

#should be 2 diets * 16 ingredients * 3 top source countries
length(ingredient_per_country_per_diet)

this_ingredient_source <- ingredient_per_country_per_diet[[1]]

#allocating demand on spatial production layers by diet, ingredient, and source country
AllocateSpatialCropDemand <- \(this_ingredient_source){
  
  #parameters within diet-ingredient-source demand data
  this_diet <- unique(this_ingredient_source$diet)
  
  this_country <- unique(this_ingredient_source$source_iso3c)
  
  this_ingredient <- unique(this_ingredient_source$ingredients)
  
  this_mapspam_code <- unique(this_ingredient_source$map_spam_code)
  
  this_demand_quantity <- unique(this_ingredient_source$total_crop_demand)
  
  this_current_production <- unique(this_ingredient_source$mean_value)
  
  #the file_name of interest for this diet, ingredient, and country
  this_demand_raster_filename <- here(sprintf("data/spatial/%s/%s_AllTech_%s.tif", this_diet, this_ingredient, this_country))
  
  #if the file name doesn't exist, create it
  if(file.exists(this_demand_raster_filename)){
    
    #spatial adjustments of production data by current production
    this_country_raster <- rast(here(sprintf("data/spatial/00-country-rasters/%s.tif", this_country)))
    
    this_global_production_raster <- rast(list.files(here("data/spatial/02-crop-layers-reprojected"), pattern = sprintf("_P_%s_A", toupper(this_mapspam_code)), full.names = TRUE))
    
    this_country_production_raster <- this_global_production_raster*this_country_raster
    
    this_updated_country_production_raster <-  this_country_production_raster* this_current_production/sum(terra::values(this_country_production_raster), na.rm=TRUE)
    
    this_demand_production_ratio <-
      min(1, this_demand_quantity/this_current_production)
  
    this_demand_raster <- this_updated_country_production_raster*this_demand_production_ratio
      
    terra::writeRaster( x=this_demand_raster, filename =  this_demand_raster_filename, overwrite=TRUE)
    
  }
}

mclapply(X = ingredient_per_country_per_diet, FUN = AllocateSpatialCropDemand, mc.cores = detectCores()-2)




```

