---
title: "Spatial Allocation of Crop Demand"
output: html_document
---

```{r}
library(tidyverse)
library(here)
library(terra)
library(parallel)

source(here("src/directories.R"))
source(here("src/spatial.R"))

base_raster_ea <- rast(here("data/spatial/base_raster_gall_peters.tif"))

select <- dplyr::select
```

This chunk of code brings in the crop production raster (only the production layers for all types) and reprojects to equal area projections for each crop)
```{r}

crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

crop_list <- unique(crop_demand$map_spam_code)

crop_production_files <- list.files(file.path(mapspam_dir, "new-extents"), full.names = TRUE)[grep(pattern = "_P_", list.files(file.path(mapspam_dir, "new-extents"), full.names = TRUE))] 

these_crop_production_files <- crop_production_files[grepl("MAIZ_A|OPUL_A|WHEA_A|RAPE_A|OOIL_A|SOYB_A|SUNF_A", crop_production_files)]


#for testing the below function
this_code <- crop_list[[1]]
this_filepath <- these_crop_production_files[[5]]


#NOTE::: the function below runs fine (i.e. raster files are reprojected and produced) but introducing terra spat rasters instead of raster::rasters created an error "Error in x@ptr$nrow() : external pointer is not valid" when printing the raster. Still searching for solutions. It is to do with parallelisng SpatRaster see - https://github.com/rspatial/terra/issues/166 . So have switched to lapply to make sure code runs.

lapply(X = these_crop_production_files, FUN = \(this_filepath){
  
  this_file <- basename(this_filepath)
      
    #import the raster
    imported_file <- rast(this_filepath)
    
    #reproject the file
    reprojected_file <-  project(x=imported_file, y= base_raster_ea)
    
    #write the original and the reprojected to this project
    writeRaster(imported_file, filename = paste0(here("data/spatial/01-crop-layers-raw/"), this_file), overwrite = TRUE)
    writeRaster(reprojected_file, filename = paste0(here("data/spatial/02-crop-layers-reprojected/"), this_file), overwrite=TRUE)
  
  
})
  

#this code is need for the physical area layers stuff in the biodiversity paper so leaving in for now. 
    #imported_file <- imported_file*0.01 #converts the imported raster to km2 from ha 
    

```

We're now interested from where the different crop ingredients could be sourced across the top producing nations. Need to check whether the demand from the global salmon industry

```{r}
crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

#check that demand for each rawe material on each country in the various diets does not outsrtip national production (if so we need to adjust AllocateSpatialCropDemand function to be more defensive).

top_10_producers <- read_csv(here("data/tidy_data/production-data/top_crop_producers_conversions.csv")) |> 
  mutate(ingredient = if_else(ingredient == "canola/camelina oil", true = "canola_camelina oil", false = ingredient))


(crop_demand_production_compare <- 
  crop_demand |> 
  left_join(top_10_producers |> 
              select(-c(cf, X7)), 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
    mutate(demand_production_ratio = total_crop_demand/mean_value,
           check = demand_production_ratio>1) %>% 
    rename(national_production = mean_value)
    
    )

#Demand only exceeds production for the top 3 producers for guar (only India can support this demand from global salmon. But this isn't bad given we only have footprint information for India)

crop_demand_production_compare |> 
  group_by(ingredients, diet) |> 
  mutate(producer_order = 1:10) |> 
  filter(check != TRUE)


saveRDS(object = crop_demand_production_compare, file = here("data/tidy_data/demand/crop_demand_production_compare.rds"))


```

Make some decisions about which countries to include. The idea is to deliberately select countries that have variable environmental midpoints to illustrate the relative contribution of source and diet. Import the agrifootprint data.

```{r}
#import the crop lca data
all_crop_pressures <-  readRDS(file = here("data/tidy_data/LCA/crop_lca.rds"))

unique(all_crop_pressures$impact_category)

#filter for the pressures of interest
crop_main_pressures <- all_crop_pressures |> filter(impact_category %in% c("Global warming", "Water use", "Eutrophication, freshwater", "Eutrophication, marine", "Land use"))


#match up country-specific pressure data with country production/demand data. Want to constrain the ocujntries used for LCA variability by those that can plausibly source demand

(plausible_crop_sourcing_list <- crop_demand_production_compare |> select(ingredients, diet, FAOSTAT_name, source_iso3c, total_crop_demand, national_production, demand_production_ratio, check) |>  filter(check == FALSE & ingredients!= "guar meal") |> group_split(ingredients) |> unique())

which_crop_countries

```




```{r}
#BREAK up the main producers by the top 3


ingredient_per_country_per_diet <- 
  crop_demand |> group_split(diet, ingredients) |> map_df(\(df){df |> slice(1:3)}) |> 
  left_join(top_10_producers |> group_split( ingredient) |> map_df(\(df){df |> slice(1:3)}) |> 
              select(-c(cf, X7, iso3c)), 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
  filter(!(ingredients == "guar meal" & source_iso3c %in% c("KEN", "ETH"))) |> #filter guar by only including INdia
  filter(total_ingredient_demand != 0) |> 
  group_split(diet, ingredients, source_country)


length(ingredient_per_country_per_diet)

this_ingredient_source <- ingredient_per_country_per_diet[[1]]

#allocating demand on spatial production layers by diet, ingredient, and source country
AllocateSpatialCropDemand <- \(this_ingredient_source){
  
  #parameters within diet-ingredient-source demand data
  this_diet <- unique(this_ingredient_source$diet)
  
  this_country <- unique(this_ingredient_source$source_iso3c)
  
  this_ingredient <- unique(this_ingredient_source$ingredients)
  
  this_mapspam_code <- unique(this_ingredient_source$map_spam_code)
  
  this_demand_quantity <- unique(this_ingredient_source$total_crop_demand)
  
  this_current_production <- unique(this_ingredient_source$mean_value)
  
  #the file_name of interest for this diet, ingredient, and country
  this_demand_raster_filename <- here(sprintf("data/spatial/%s/%s_AllTech_%s.tif", this_diet, this_ingredient, this_country))
  
  #if the file name doesn't exist, create it
  if(file.exists(this_demand_raster_filename)){
    
    #spatial adjustments of production data by current production
    this_country_raster <- rast(here(sprintf("data/spatial/00-country-rasters/%s.tif", this_country)))
    
    this_global_production_raster <- rast(list.files(here("data/spatial/02-crop-layers-reprojected"), pattern = sprintf("_P_%s_A", toupper(this_mapspam_code)), full.names = TRUE))
    
    this_country_production_raster <- this_global_production_raster*this_country_raster
    
    this_updated_country_production_raster <-  this_country_production_raster* this_current_production/sum(terra::values(this_country_production_raster), na.rm=TRUE)
    
    this_demand_production_ratio <-
      min(1, this_demand_quantity/this_current_production)
  
    this_demand_raster <- this_updated_country_production_raster*this_demand_production_ratio
      
    terra::writeRaster( x=this_demand_raster, filename =  this_demand_raster_filename, overwrite=TRUE)
    
  }
}

mclapply(X = ingredient_per_country_per_diet, FUN = AllocateSpatialCropDemand, mc.cores = detectCores()-2)




```

