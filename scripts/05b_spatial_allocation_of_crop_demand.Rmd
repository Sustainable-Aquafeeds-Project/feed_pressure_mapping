---
title: "Spatial Allocation of Crop Demand"
output: html_document
---

```{r}
library(tidyverse)
library(here)
library(raster)
library(parallel)

source(here("src/directories.R"))
source(here("src/spatial.R"))

select <- dplyr::select
```


```{r}

crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

crop_list <- unique(crop_demand$map_spam_code)

mclapply(X=crop_list, FUN =  \(this_code){
  #identify all files for each crop
  these_crop_files <- list.files(file.path(mapspam_dir, "new-extents"), pattern = sprintf("_%s_", toupper(this_code)), full.names = TRUE)
  these_crop_filenames <- list.files(file.path(mapspam_dir, "new-extents"), pattern = sprintf("_%s_", toupper(this_code)))
  map2(.x = these_crop_files, .y = these_crop_filenames, .f = \(this_file, this_filename){
    #import the raster
    imported_file <- raster(this_file)
    imported_file <- imported_file*0.01 #converts the imported raster to km2 from ha
    reprojected_file <-  projectRaster(from = imported_file, to = base_raster_ea)
    #reprojected_file <- (reprojected_file) 
    
    writeRaster(imported_file, filename = paste0(here("data/spatial/01-crop-layers-raw/"), this_filename), overwrite=TRUE)
    writeRaster(reprojected_file, filename = paste0(here("data/spatial/02-crop-layers-reprojected/"), this_filename), overwrite=TRUE)
  }
  )
},
mc.cores = detectCores()-2
)


```


We're intetrested in the impacts of different diets depending on their make-up and where they are sourced from so probably organise the spatial outputs by diet but also the source country and the ingredient (rather than the crop as we want impacts to be associated per ingredient).
```{r}
crop_demand <- readRDS(here("data/tidy_data/demand/total_crop_demand.rds"))

#check that demand for each rawe material on each country in the various diets does not outsrtip national production (if so we need to adjust AllocateSpatialCropDemand function to be more defensive)

top_10_producers <- read_csv(here("data/tidy_data/production-data/top_crop_producers_conversions.csv")) |> 
  mutate(ingredient = if_else(ingredient == "canola/camelina oil", true = "canola_camelina oil", false = ingredient))

(demand_production_compare <- 
  crop_demand |> 
  left_join(top_10_producers |> 
              select(-c(cf, X7)) , 
            by = c("ingredients"="ingredient", "FAOSTAT_name"="item", "source_country" = "area")) |> 
    mutate(demand_production_ratio = total_crop_demand/mean_value,
           check = demand_production_ratio>1))

countries_crops_demand_greaterthan_production <- demand_production_compare |> filter(check==TRUE)

ingredient_per_country_per_diet <- crop_demand |> 
  group_split(diet, ingredients, source_country)

#should be 15 diets * 16 ingredients * 10 top source countries
length(ingredient_per_country_per_diet)


#allocating demand on spatial production layers by diet, ingredient, and source country
AllocateSpatialCropDemand <- \(this_ingredient_source){
  
  #parameters within diet-ingredient-source demand data
  this_diet <- unique(this_ingredient_source$diet)
  
  this_country <- unique(this_ingredient_source$source_iso3c)
  
  this_ingredient <- unique(this_ingredient_source$ingredients)
  
  this_mapspam_code <- unique(this_ingredient_source$map_spam_code)
  
  this_demand_quantity <- unique(this_ingredient_source$total_crop_demand)
  
  #the file_name of interest for this diet, ingredient, and country
  this_demand_raster_filename <- here(sprintf("data/spatial/%s/%s_AllTech_%s.tif", this_diet, this_ingredient, this_country))
  
  #if the file name doesn't exist, create it
  if(file.exists(this_demand_raster_filename)){
    
    #spatial adjustments of area data by demand
    this_country_raster <- raster(here(sprintf("data/spatial/00-country-rasters/%s.tif", this_country)))
    
    #using all technologiwa at present - may want to disaggregate by rainfed or irrigated
    this_global_area_raster <- raster(list.files(here("data/spatial/02-crop-layers-reprojected"), pattern = sprintf("_A_%s_A", toupper(this_mapspam_code)), full.names = TRUE))
    this_global_production_raster <- raster(list.files(here("data/spatial/02-crop-layers-reprojected"), pattern = sprintf("_P_%s_A", toupper(this_mapspam_code)), full.names = TRUE))
    
    this_country_area_raster <- this_global_area_raster*this_country_raster
    
    this_country_production_raster <- this_global_production_raster*this_country_raster
    
    this_demand_production_ratio <- this_demand_quantity/sum(raster::values(this_country_production_raster), na.rm = TRUE)
    
    #at present this scales the production area for country-ingredient combos. Where demand  is bigger than current production this expands the area beyond the current growing region. To my mind this meets the assumption that expansion provides (on average) a smaller bottleneck that does improving yields. Could also just make the ratio one where demand outstrips production
    this_demand_raster <- this_country_area_raster*this_demand_production_ratio
      
    raster::writeRaster( x=this_demand_raster, filename =  this_demand_raster_filename, overwrite=TRUE)
    
  }
}

mclapply(X = ingredient_per_country_per_diet, FUN = AllocateSpatialCropDemand, mc.cores = detectCores()-2)


```

